const aws = require('aws-sdk');
const fs = require('fs');
const path = require('path');

const serviceMappings = require('./service-mappings-node.json');
const policies = require('./policies.json');
const dynamooseSdkPath = './dynamoose_sdk/dynamoose-sdk.js'

const new_line = "\n";
const tab = "    ";
const protegoAWSNamespace = "ProtegoAWSNamespace"
const protegoAPIUsageEnd = "__protego_api_usage_end__";

const SPECIAL_OPERATIONS = {
    "s3": [
        'getSignedUrl'
    ]
}

class AWSSDKGenerator {
    static getServiceName(className) {
        return serviceMappings[aws[className].serviceIdentifier];
    }

    static apiUsagePrefix() {
        return '__protego_api_usage__;';
    }

    static getProtegoAWSNamespace() {
        return protegoAWSNamespace;
    }

    static generateReplaceObjects() {
        let clients = { "aws-sdk": protegoAWSNamespace, "aws-xray-sdk": protegoAWSNamespace + ".XRay", "dynamoose": protegoAWSNamespace };
        for (const className in aws) {
            if (typeof aws[className].serviceIdentifier !== 'undefined') {
                clients["aws-sdk/clients/" + aws[className].serviceIdentifier] = protegoAWSNamespace + "." + className;
            }
        }
        return clients;
    }

    static getAWSServices() {
        const services = new Set();
        for (const className in aws) {
            if (typeof aws[className].serviceIdentifier !== 'undefined') {
                services.add(className);
            }
            let subServices = privateMethods.getSubServices(className, aws[className])
            if (subServices.length > 0) {
                for (let subService of subServices) {
                    services.add(subService)
                }
            }
        }
        return services;
    }

    static getMissingPermissions(serviceName, literals) {
        let missingPermissions = [];
        const permissions = policies[serviceName];
        for (let literal of literals) {
            const permission = permissions[literal.charAt(0).toUpperCase() + literal.substr(1)]
            if (typeof permission === 'string') {
                missingPermissions.push(permission);
            } else if (Array.isArray(permission)) {
                missingPermissions = missingPermissions.concat(permission);
            }
        }
        return missingPermissions;
    }

    static getSpecialPermissions(serviceName, action) {
        if (typeof policies[serviceName] === 'undefined' || typeof policies[serviceName][action] === 'undefined') {
            console.log("Failed to find special permission for service: " + serviceName + ", action: " + action);
            return [serviceName + ":*"];
        }

        return policies[serviceName][action];
    }

    static isSepcialOperation(serviceName, operation) {
        return typeof SPECIAL_OPERATIONS[serviceName] !== 'undefined' && SPECIAL_OPERATIONS[serviceName].includes(operation);
    }

    generate(filename, callback) {
        console.log("Generating AWS classes...");

        try {
            let wfd = fs.openSync(filename, 'w');

            let exportAWS = "/**" + new_line + " * @const" + new_line + " */" + new_line;
            exportAWS += "var " + protegoAWSNamespace + " = {};" + new_line + new_line;
            fs.writeSync(wfd, exportAWS);

            for (let className in aws) {
                if (typeof aws[className]['serviceIdentifier'] !== 'undefined') {

                    const serviceName = serviceMappings[aws[className]['serviceIdentifier']];

                    // Ignore service which is not present in serviceMappings
                    if (typeof serviceName === 'undefined') {
                        continue;
                    }

                    // TODO: Sent skipNotRecorded flag as true once we cover all the apis
                    const cls = privateMethods.generateClass(aws[className], className, serviceName);
                    privateMethods.saveClass(wfd, cls, className);

                    // Genrate any sub services in aws service class
                    privateMethods.generateSubService(wfd, className, aws[className]);
                }
            }
            privateMethods.addDynamooseSDK(wfd) //for dynamoose wrapper support
            fs.closeSync(wfd);
        } catch (err) {
            console.error("Failed to generation AWS classes...");
            callback(err);
            return;
        }

        console.log("AWS classes generation complete...");
        callback(null);
    }
}

const privateMethods = {
    getServiceOperations(service) {
        let clsInstance = new service({ endpoint: 'my.host.tld' });
        if (typeof clsInstance.api === "undefined") {
            // This is a class inside service, so return __proto__
            return clsInstance.__proto__;
        }
        return clsInstance.api.operations;
    },
    getAPIUsagePrefix(className, parent) {
        if (parent) {
            // For class inside service return name of parent
            // e.g.: For DyanamoDB.DocumentClient this will use DynamoDB as service
            return AWSSDKGenerator.apiUsagePrefix() + parent + ";";
        }
        return AWSSDKGenerator.apiUsagePrefix() + className + ";";
    },
    getFullyQualifiedName(className, parent) {
        let name = protegoAWSNamespace + ".";
        if (parent) {
            name += parent + ".";
        }
        name += className;
        return name;
    },
    saveClass(wfd, cls, className, parent) {
        fs.writeSync(wfd, cls);
    },
    // Generate class for sub-service
    // e.g.: DynamoDB.DocumentClient
    generateSubService(wfd, parent, service) {
        for (let className in service) {
            if ((typeof service[className]) !== "function" || className === "__super__") {
                continue;
            }
            const serviceName = serviceMappings[service.serviceIdentifier + "." + service[className].name];

            // Ignore service which is not present in serviceMappings
            if (typeof serviceName === 'undefined') {
                continue;
            }
            const cls = privateMethods.generateClass(service[className], className, serviceName, parent, true);
            privateMethods.saveClass(wfd, cls, className, parent);
        }
    },
    getAction(serviceName, api) {
        const permissions = policies[serviceName];
        const actions = permissions['Actions'];
        if (typeof actions === 'undefined') {
            return api;
        }

        return actions[api.charAt(0).toUpperCase() + api.substr(1)];
    },
    generateClass(service, className, serviceName, parent, skipNotRecorded) {
        const apiUsagePrefix = privateMethods.getAPIUsagePrefix(className, parent);
        const operations = privateMethods.getServiceOperations(service);

        const fqn = privateMethods.getFullyQualifiedName(className, parent);
        let cls = "/** " + new_line;
        cls += " * @constructor" + new_line;
        cls += " * @param {Object=} params" + new_line;
        cls += " */" + new_line;
        cls += fqn + " = function (params) {};" + new_line + new_line;
        for (let api in operations) {
            if (api === "constructor") {
                // We don't want to generate constructor calls as no permission
                // is associated with it
                continue;
            }
            const permission = privateMethods.getPermission(serviceName, api, skipNotRecorded);

            if (!permission) {
                continue;
            }
            const action = privateMethods.getAction(serviceName, api);
            cls += "/** @this {" + fqn + "} */" + new_line;
            cls += fqn + ".prototype." + api + " = function(params, callback) {" + new_line;
            cls += privateMethods.generateAPICallback(apiUsagePrefix, permission, fqn, action);
            cls += tab + "callback(null, 'ProtegoData');" + new_line
            cls += "};" + new_line + new_line;
        }
        cls += privateMethods.generateSpecialOperations(serviceName, className, fqn);
        return cls;
    },
    generateAPICallback(apiUsagePrefix, permissions, fqn, api) {
        if (typeof permissions === "string") {
            return tab + "console.log( \"" + apiUsagePrefix + fqn + ";" + api + ";" + permissions + "\" + JSON.stringify(params) + \"" + protegoAPIUsageEnd + "\");" + new_line;
        }
        const permission = permissions.join(",");
        return tab + "console.log( \"" + apiUsagePrefix + fqn + ";" + api + ";" + permission + "\" + JSON.stringify(params) + \"" + protegoAPIUsageEnd + "\");" + new_line;
    },
    // Searches for permission in policies.json file
    // returns undefined if entry is not found and skipNotRecorded is true
    getPermission(serviceName, api, skipNotRecorded) {
        let permission = privateMethods.toPermission(api, serviceName);
        if (typeof permission === 'undefined' && !skipNotRecorded) {
            if (process.env['PROTEGO_DEBUG_LEVEL'] === "DEBUG") {
                console.log(serviceName + '.' + api + ' is missing in policies.json');
            }
            return serviceName + ":*";
        }
        return permission;
    },

    toPermission(api, serviceName) {
        const permissions = policies[serviceName];
        return permissions[api.charAt(0).toUpperCase() + api.substr(1)];
    },
    generateSpecialOperations(serviceName, className, fqn) {
        if (serviceName === "s3") {
            return privateMethods.generateS3SpecialOperations(className, fqn);
        }

        if (serviceName === "xray") {
            return privateMethods.generateXRaySpecialOperations(className, fqn);
        }
        return "";
    },
    generateS3SpecialOperations(className, fqn) {
        let specialOperations = "/** @this {" + protegoAWSNamespace + "." + className + "} */" + new_line;
        specialOperations += protegoAWSNamespace + "." + className + ".prototype." + "getSignedUrl = function(operation, params, callback) {" + new_line;

        const apiUsagePrefix = privateMethods.getAPIUsagePrefix(className, null);
        specialOperations += tab + "console.log(\"" + apiUsagePrefix + fqn + ";getSignedUrl" + ";\" + operation + JSON.stringify(params) + \"" + protegoAPIUsageEnd + "\");" + new_line;
        specialOperations += tab + "callback(null, 'ProtegoData');" + new_line
        specialOperations += "};" + new_line + new_line;

        specialOperations += "/** @this {" + protegoAWSNamespace + "." + className + "} */" + new_line;
        specialOperations += protegoAWSNamespace + "." + className + ".prototype." + "upload = function(params, callback) {" + new_line;
        specialOperations += tab + "console.log(\"" + apiUsagePrefix + fqn + ";upload" + ";s3:PutObject\" + JSON.stringify(params) + \"" + protegoAPIUsageEnd + "\");" + new_line;
        specialOperations += tab + "callback(null, 'ProtegoData');" + new_line
        specialOperations += "};" + new_line + new_line;
        return specialOperations;
    },
    generateXRaySpecialOperations(className, fqn) {
        let captureAWS = "/** @this {" + protegoAWSNamespace + "." + className + "} */" + new_line;
        captureAWS += protegoAWSNamespace + "." + className + ".prototype." + "captureAWS = function(params) {" + new_line;
        captureAWS += tab + "return params;" + new_line;
        captureAWS += "};" + new_line + new_line;

        let captureAWSClient = "/** @this {" + protegoAWSNamespace + "." + className + "} */" + new_line;
        captureAWSClient += protegoAWSNamespace + "." + className + ".prototype." + "captureAWSClient = function(params) {" + new_line;
        captureAWSClient += tab + "return params;" + new_line;
        captureAWSClient += "};" + new_line + new_line;

        return captureAWS + captureAWSClient;
    },
    addDynamooseSDK(wfd) {
        let dynamoosesdkData = fs.readFileSync(path.join(__dirname, dynamooseSdkPath));
        fs.writeSync(wfd, dynamoosesdkData);
    },
    getSubServices(parent, service) {
        let subServiceList = [];
        for (let className in service) {
            if ((typeof service[className]) !== "function" || className === "__super__") {
                continue;
            }
            let serviceName = parent + "." + service[className].name;
            subServiceList.push(serviceName);
        }
        return subServiceList;
    }
}

module.exports = AWSSDKGenerator;
