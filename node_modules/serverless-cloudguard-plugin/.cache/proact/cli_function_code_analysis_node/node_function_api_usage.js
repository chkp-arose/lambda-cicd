"use strict";

const fs = require('fs');
const path = require('path');
const mkdirp = require('mkdirp');

const optimization_out_file = '/out.js';
const protego_fau_handler_file = 'protego_fau_handler.js';

const use_ecma5 = "--language_out ECMASCRIPT5";
const use_ecma6 = "--language_out ECMASCRIPT6";

const language_in = "--language_in ECMASCRIPT_NEXT";

const AWSSDKGenerator = require('./aws_sdk_generator');
const ExpandEval = require('./expand_eval');
const CodeParser = require('./code_parser');
const webpack = require('webpack');
const error = require('./error');

const webpackDir = '/webpack';
const ccDir = '/cc';
const protegoCodeDir = '/code';
const excludeEnvList = ['NODE_OPTIONS', 'DEBUG', 'LOG_LEVEL'];

const node_modules_path = process.env.PROTEGO_NODE_MODULES_PARENT || __dirname;

class NodeFunctionApiUsage {
    getAPIs(event, codeDir, gProtegoDir, callback) {
        privateMethods.getAPIUsage.call(this, codeDir, gProtegoDir, event, (err, apiUsage) => {
            if (err) {
                callback(err, event);
                return;
            }
            if (Object.keys(apiUsage).length != 0) {
                event["FunctionData"]["FunctionApiUsage"] = apiUsage["FunctionApiUsage"];
                event["FunctionData"]["FunctionApiAnalysis"] = apiUsage["FunctionApiAnalysis"];
                if (apiUsage["IncludesFSPCodeAnalysis"]) {
                    console.log("IncludesFSPCodeAnalysis value is " + apiUsage["IncludesFSPCodeAnalysis"]);
                    console.log("Setting IncludesFSP to: " + apiUsage["IncludesFSPCodeAnalysis"]);
                    event["FunctionData"]["IncludesFSPCodeAnalysis"] = apiUsage["IncludesFSPCodeAnalysis"];
                }
            }
            callback(null, event);
        });
    }
}

const privateMethods = {

    getAPIUsage(codeDir, gProtegoDir, event, callback) {
        const expand_eval = new ExpandEval();
        const res = expand_eval.getEntryPoint(event, codeDir);
        const entry_point = res.EntryPoint
        console.log("entry_point is--->" + entry_point);

        if (!entry_point) {
            callback(new error.InvalidEntryPointError(res.Error));
            return;
        }

        expand_eval.expandEval(entry_point);

        privateMethods.parse_files.call(this, entry_point, codeDir, gProtegoDir, event, (err, entry_path) => {
            if (err) {
                callback(err);
                return;
            }
            privateMethods.package_modules.call(this, entry_point, entry_path, gProtegoDir, codeDir, (err, out_path) => {
                if (err) {
                    callback(err);
                    return;
                }
                console.log("language_in: " + language_in);
                privateMethods.run_closure_compiler.call(this, gProtegoDir, out_path, use_ecma5, (err, outjs_path) => {
                    if (err) {
                        console.log("Optimization Failed with ES5, retrying with ES6...");
                        privateMethods.run_closure_compiler.call(this, gProtegoDir, out_path, use_ecma6, (err, outjs_path) => {
                            if (err) {
                                console.error("Optimization Failed with ES6...");
                                callback(err);
                                return;
                            }
                            const all_apis = privateMethods.find_api_usage.call(this, outjs_path, out_path);
                            callback(null, all_apis);
                        });
                    } else {
                        const all_apis = privateMethods.find_api_usage.call(this, outjs_path, out_path);
                        callback(null, all_apis);
                    }
                });
            });
        });
    },

    deleteFolderRecursive(dir_path) {
        if (fs.existsSync(dir_path)) {
            fs.readdirSync(dir_path).forEach(function (file, index) {
                const curPath = dir_path + "/" + file;
                if (fs.lstatSync(curPath).isDirectory()) { // recurse
                    privateMethods.deleteFolderRecursive.call(this, curPath);
                } else { // delete file
                    fs.unlinkSync(curPath);
                }
            });
            fs.rmdirSync(dir_path);
        }
    },

    searchNodeModulesRecursive(dir_path) {
        const find = require('find');
        return find.dirSync(/\/node_modules$/, dir_path);
    },

    getHandlerDir(handler, gProtegoDir) {
        let handlerDir = path.dirname(handler);
        // Replace the /tmp/protego/code directory with replace as it is our new root
        return handlerDir.replace(protegoCodeDir, gProtegoDir + protegoCodeDir)
    },

    copyDeps(gProtegoDir, callback) {
        callback(null, __dirname + "/deps");
    },

    listFilesSync(rootDir, filelist) {
        if (!fs.existsSync(rootDir)) {
            return [];
        }
        let files = fs.readdirSync(rootDir);
        filelist = filelist || [];
        files.forEach(function (file) {
            if (fs.statSync(rootDir + '/' + file).isDirectory()) {
                filelist = privateMethods.listFilesSync(rootDir + '/' + file, filelist);
            } else {
                filelist.push(rootDir + '/' + file);
            }
        });
        return filelist;
    },

    parse_files(entry_point, codeDir, gProtegoDir, event, callback) {
        let files = privateMethods.listFilesSync(codeDir.functionCodeLocation, []);
        files = files.concat(privateMethods.listFilesSync(codeDir.functionLayerLocation, []));
        let replace_aws_sdk = AWSSDKGenerator.generateReplaceObjects();
        const awsServices = AWSSDKGenerator.getAWSServices();

        const filesToParse = files.filter(file => file.endsWith('.js') || file.endsWith('package.json'));
        filesToParse.forEach(file => {
            const fd = fs.openSync(file, 'r');
            const data = fs.readFileSync(fd, 'utf-8').toString();
            fs.closeSync(fd);
            let result = data;
            if (data) {
                if (file.endsWith('.js')) {
                    // Replace aws-sdk with protego implementations
                    result = privateMethods.replaceAwsSdk.call(this, replace_aws_sdk, result);
                    // webpack gives invalid assignment error when 'process.env.NODE_ENV' and 'process.env.DEBUG`, 'process.env.LOG_LEVEL' is set to something..
                    // so replacing it with our 'process.env.PROTEGO_NODE_ENV' & 'process.env.DEBUG' , `process.env.PROTEGO_LOG_LEVEL_ENV` respectively.
                    result = privateMethods.replaceNodeEnv.call(this, result);

                    result = privateMethods.replaceWebpackDebugEnv.call(this, result);

                    result = privateMethods.replaceWebpackLogLevelEnv.call(this, result);

                    result = privateMethods.replaceServiceCalls.call(this, awsServices, result);
                }
                if (file.endsWith("package.json")) {
                    try {
                        JSON.parse(data)
                    } catch (e) {
                        result = "{}"
                    }
                }

                if (result !== data) {
                    try {
                        let wfd = fs.openSync(file, 'w');
                        fs.writeSync(wfd, result);
                        fs.closeSync(wfd);
                    } catch (err) {
                        console.log('Error writing file:' + err);
                        callback(err);
                        return;
                    }
                }
            }
        });
        console.log("AWS SDK replace complete");

        privateMethods.updateLambdaEnvironment(gProtegoDir, event);

        const aws_sdk_generator = new AWSSDKGenerator();

        aws_sdk_generator.generate(gProtegoDir + '/protego-aws-sdk.js', function (err) {
            if (err) {
                console.error("aws_sdk_generator.generate failed with error: " + err);
                callback(err);
                return;
            }

            const entry_pt = event["FunctionData"]["Handler"];
            const entry_parts = entry_pt.split('.');
            const function_handler = entry_parts.pop();

            let result = "const handler = require('" + entry_point.substring(0, entry_point.length - '.js'.length) + "');\n";
            result += "handler." + function_handler + "(event, context, callback);";

            try {
                let writeStream = fs.createWriteStream(codeDir.functionCodeLocation + '/' + protego_fau_handler_file);
                writeStream.write(result);
                writeStream.end();
            } catch (w_err) {
                console.error("Failed to write file with error: " + w_err);
                callback(w_err);
                return;
            }
            const entry_path = codeDir.functionCodeLocation;
            console.log('entry_path: ' + entry_path);
            if (fs.existsSync(entry_path)) {
                callback(null, entry_path);
            } else {
                const err_msg = "replace directory not found: " + entry_path;
                console.log(err_msg);
                callback(new error.InvalidDirectoryPathError(err_msg));
                return;
            }
        });
    },

    updateLambdaEnvironment(protegoRootDir, event) {
        const env = event["FunctionData"]["Environment"];
        if (typeof env !== "undefined") {
            const envVariables = event["FunctionData"]["Environment"]["Variables"];
            if (typeof envVariables !== "undefined") {
                let envKeyArr = [];
                for (const key in envVariables) {
                    if (!(excludeEnvList.indexOf(key) > -1)) {
                        process.env[key] = envVariables[key];
                        envKeyArr.push(key);
                    }
                }
                process.env["WEB_PACK_ENV_KEY_ARR"] = envKeyArr;
            }
        }
    },

    package_modules(handler, entry_point, gProtegoDir, codeDir, callback) {

        let modules_array = privateMethods.searchNodeModulesRecursive.call(this, entry_point);
        modules_array.push(entry_point);

        // Add handler directory to modules path to resolve relative path calls
        const handlerDir = privateMethods.getHandlerDir.call(this, handler, gProtegoDir);
        modules_array.push(handlerDir);

        //Add layer code in modules_array
        if (codeDir.functionLayerLocation !== "") {
            modules_array.push(codeDir.functionLayerLocation);
            const layers_module_array = privateMethods.searchNodeModulesRecursive.call(this, codeDir.functionLayerLocation);
            modules_array = modules_array.concat(layers_module_array);
        }

        privateMethods.copyDeps.call(this, gProtegoDir, function (err, depsDir) {
            if (err) {
                callback(err);
                return;
            }

            modules_array.push(depsDir);
            let out_path = gProtegoDir + webpackDir;

            if (!fs.existsSync(out_path)) {
                mkdirp.sync(out_path);
                //fs.mkdirSync(out_path, { recursive: true });
            }
            const entry_pt = entry_point + "/" + protego_fau_handler_file;

            let env_var_list;

            if (process.env["WEB_PACK_ENV_KEY_ARR"] == null || process.env["WEB_PACK_ENV_KEY_ARR"] == undefined) {
                //take a dummy var for webpack.EnvironmentPlugin plugin
                env_var_list = "PROTEGO_DATA_ENV";
            } else {
                env_var_list = process.env["WEB_PACK_ENV_KEY_ARR"];
            }
            const env_var_arr = env_var_list.split(',');

            const pluginsList = [new webpack.ProvidePlugin({
                Promise: 'es6-promise'
            }), new webpack.IgnorePlugin(/\.(html|json)$/),
            new webpack.EnvironmentPlugin(env_var_arr)];

            privateMethods.run_webpack.call(this, entry_pt, out_path, modules_array, pluginsList, (err, out_path) => {
                if (err) {
                    const optional_requires = privateMethods.get_optional_requires.call(this, err);
                    if (optional_requires.length === 0) {
                        console.log(err);
                        callback(new error.WebpackError(err));
                        return;
                    }
                    let out_path = gProtegoDir + webpackDir;
                    const plugins = optional_requires.concat(pluginsList);
                    privateMethods.run_webpack.call(this, entry_pt, out_path, modules_array, plugins, (err, out_path) => {
                        if(err){
                            console.log(err);
                            callback(new error.WebpackError(err));
                            return;
                        }
                        callback(null, out_path);
                    });
                    return;
                }
                callback(null, out_path);
            });
        });
    },

    run_webpack(entry_pt, out_path, modules_array, plugins, callback) {
        try {
            let rules = [
                {
                    test: /\.m?js$/,
                    use: {
                        loader: 'babel-loader',
                        options: {
                            cacheDirectory: true,
                            presets: ['@babel/preset-env'],
                            plugins: ['@babel/plugin-proposal-class-properties']
                        }
                    },
                },
                {
                    // Fix for .mjs files, ref: https://github.com/apollographql/react-apollo/issues/1737
                    type: 'javascript/auto',
                    test: /\.mjs$/,
                    use: []
                },
                {
                    test: /\.js$/,
                    use: ["remove-hashbag-loader", "octal-number-loader"]
                }
            ];
            console.log("packaging...");
            webpack({
                target: 'node',
                entry: entry_pt,
                module: {
                    rules: rules
                },
                resolveLoader: {
                    alias: {
                        "remove-hashbag-loader": path.join(__dirname, "./loaders/remove-hashbag-loader")
                    },
                    modules: [node_modules_path + '/node_modules']
                },
                output: {
                    path: out_path,
                    filename: 'app.js'
                },
                resolve: {
                    modules: modules_array
                },
                plugins: plugins,
                mode: 'production'
            }, function (err, stat) {
                const error_array = stat["compilation"]["errors"];
                if (error_array.length > 0) {
                    console.error("packaging failed!!");
                    callback(error_array);
                    return;
                }
                console.log("packaging done!!");
                fs.readdirSync(out_path).forEach(new_file => {
                    out_path = out_path + '/' + new_file;
                    callback(null, out_path);
                });
            });
        } catch (webpkError) {
            callback([webpkError]);
        }
    },

    get_optional_requires(errors) {
        let optional_requires = [];
        for (let error of errors) {
            if (error.name !== 'ModuleNotFoundError' || error.dependencies === 'undefined') {
                continue;
            }
            for (let dependency of error.dependencies) {
                if (dependency.request === 'undefined') {
                    continue;
                }
                optional_requires.push(dependency.request);
            }
        }
        if (optional_requires.length === 0) {
            return [];
        }
        console.log('optional_requires: ' + optional_requires);
        let requires_regex = new RegExp(optional_requires.join('|'));
        return [new webpack.IgnorePlugin(requires_regex)]
    },

    run_closure_compiler(gProtegoDir, input_file, lang_out, callback) {
        try {
            const compilation_level = "--compilation_level ADVANCED_OPTIMIZATIONS";
            const input_file_param = "--js " + gProtegoDir + '/protego-aws-sdk.js' + " --js " + input_file;
            const output_file_name = gProtegoDir + ccDir + optimization_out_file;
            const compiler_jar = __dirname + "/cc/closure-compiler.jar";
            const externs = "--externs " + __dirname + "/externs/console.js";
            const cmd = ["-Xms256m -Xmx4096m", "-jar", compiler_jar, language_in, compilation_level, input_file_param, externs, "--strict_mode_input false", lang_out, "--jscomp_warning ambiguousFunctionDecl --jscomp_warning checkVars --jscomp_warning closureDepMethodUsageChecks --jscomp_warning duplicateMessage --jscomp_warning duplicate --jscomp_warning es3 --jscomp_warning es5Strict --jscomp_warning internetExplorerChecks --jscomp_warning undefinedVars --jscomp_warning violatedModuleDep", "--js_output_file", output_file_name].join(' ');
            const { spawn } = require('child_process');
            console.log("Optimizing...");
            console.time("Optimization took");
            if (!fs.existsSync(gProtegoDir + ccDir)) {
                mkdirp.sync(gProtegoDir + ccDir);
                //fs.mkdirSync(gProtegoDir + ccDir, { recursive: true });
            }
            let wfd = fs.openSync(gProtegoDir + ccDir + '/' + 'out.log', 'w');
            const args = cmd.split(' ');
            let cc = spawn("java", args, {
                shell: true
            });
            var errStr = "";
            cc.stderr.on('data', (data) => {
                errStr = errStr.concat(data.toString("utf8"));
                fs.writeSync(wfd, data);
            });
            cc.on('exit', (code, signal) => {
                fs.closeSync(wfd);
                
                console.log("Optimization completed with code: " + code + ", signal: " + signal);
                if (code === 0) {
                    console.log("Optimization done.");
                    callback(null, output_file_name);
                    return;
                }
                console.log("Optimisation failed : " + errStr);
                callback(new error.ClosureCompilerError("Optimization failed with code: " + code + ", signal: " + signal + ", Failure: " + errStr.split(/\r?\n?\t/).slice(0, 20).join("\n")));
                return;
            });
        } catch (cc_err) {
            console.log(cc_err);
            callback(cc_err);
        }
    },

    find_api_usage(ccResult, webpackResult, callback) {
        const ccContents = fs.readFileSync(ccResult, 'utf8').toString();
        const cp = new CodeParser(ccContents);
        return cp.getAPIUsage();
    },

    escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    },

    replaceAwsSdk(replace_aws_sdk, str) {
        const RelpaceAwsSdk = require('./replace_aws_sdk');
        const r = new RelpaceAwsSdk();
        return r.replace(str, replace_aws_sdk);
    },

    replaceNodeEnv(str) {
        return str.replace(new RegExp('process.env.NODE_ENV', 'g'), 'process.env.PROTEGO_NODE_ENV');
    },

    replaceWebpackDebugEnv(str) {
        return str.replace(new RegExp('process.env.DEBUG', 'g'), 'process.env.PROTEGO_DEBUG_ENV');
    },

    replaceWebpackLogLevelEnv(str) {
        return str.replace(new RegExp('process.env.LOG_LEVEL', 'g'), 'process.env.PROTEGO_LOG_LEVEL_ENV');
    },

    replaceServiceCalls(services, str) {
        const cp = new CodeParser(str);
        return cp.replaceServiceCreations(services);
    }

}

module.exports = NodeFunctionApiUsage;
