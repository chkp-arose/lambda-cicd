'use strict'

const tmp = require('tmp-promise');
const del = require('del');
const request = require('request');
const fs = require('fs');
const AWS = require('aws-sdk');

function getTmpDirPromise() {
    return tmp.dir({ dir: '/tmp', prefix: 'protego-', unsafeCleanup: true })
}

function clearTmp(dirToDelete) {
    console.log("clear tmp dir: " + dirToDelete);
    return del.sync([dirToDelete], { force: true });
}

function downloadCodeFromUrl(functionLayerData, gProtegoDir) {
    return new Promise((resolve, reject) => {
        var codeTmpLocation = {
            "functionCodeLocation": "",
            "functionLayerLocation": ""
        };

        const functionCodeLocation = gProtegoDir + '/code';
        if (!fs.existsSync(functionCodeLocation)) {
            fs.mkdirSync(functionCodeLocation);
        }
        downloadfunctionCode(functionLayerData.functionCodeUrl, functionCodeLocation, function (error, data) {
            if (error) {
                error => reject(error);
            }
            codeTmpLocation.functionCodeLocation = functionCodeLocation;
            if (functionLayerData.layersCodeUrl.length > 0) {
                downloadLayerCode(functionLayerData.layersCodeUrl, gProtegoDir, function (error, data) {
                    if (error) {
                        error => reject(error);
                    }
                    codeTmpLocation.functionLayerLocation = data;
                    resolve(codeTmpLocation);
                });
            } else {
                resolve(codeTmpLocation);
            }
        });
    });
}

function downloadfunctionCode(functionCodeUrl, tmpLocation, callback) {
    //Download and extract function code
    const codeDownloadUrl = tmpLocation + '/code.zip';
    console.log('Downloading function code to: ' + codeDownloadUrl);
    downloadAndExtractCode(functionCodeUrl, codeDownloadUrl, tmpLocation).then(functionCodeTmpLocation => {
        callback(null, functionCodeTmpLocation);
    });
}

function downloadLayerCode(layersCodeUrl, gProtegoDir, callback) {
    //Download and extract function layer code
    const functionLayerLocation = gProtegoDir + '/layers'
    console.log("Downloading layers to: " + functionLayerLocation);
    if (!fs.existsSync(functionLayerLocation)) {
        fs.mkdirSync(functionLayerLocation);
    }

    const requests = layersCodeUrl.map((layer) => {
        return new Promise((resolve, reject) => {
            const layerDownloadUrl = functionLayerLocation + '/' + layer.LayerName + layer.VersionNumber + '.zip';
            downloadAndExtractCode(layer.CodeLocation, layerDownloadUrl, functionLayerLocation).then(layerLocation => {
                resolve(layerLocation);
            });
        });
    });
    Promise.all(requests).then(() => {
        console.log("Layers Code Location : ", functionLayerLocation);
        callback(null, functionLayerLocation);
    });
}

function downloadAndExtractCode(location_url, download_url, tmpLocation, callback) {
    return new Promise((resolve, reject) => {
        request(location_url)
            .pipe(fs.createWriteStream(download_url))
            .on('close', function () {
                console.log('download complete.');
                const AdmZip = require('adm-zip');
                const zip = new AdmZip(download_url);
                try {
                    zip.extractAllTo(tmpLocation, true);
                    console.log("extraction done.");
                    fs.unlink(download_url, (err) => {
                        if (err) {
                            console.error("fs.unlink failed with error: " + err);
                            err => reject(err);
                        }
                        console.log("Returing from: " + JSON.stringify(tmpLocation));
                        resolve(tmpLocation);
                    });
                } catch (err) {
                    console.error("extraction failed with error: " + err);
                    err => reject(err);
                }
            });

    });
}

function get_function_url(event, callback) {
    if (!("LocalCodeAnalysis" in event["FunctionData"]) || (event["FunctionData"]["LocalCodeAnalysis"] != true)) {
        // remote code analysis
        console.log("get_function_url: remote code analysis");
        getFunction(event, null, function (err, code_url) {
            if (err) {
                console.error("getFunction failed with error: " + err);
                callback(err);
            } else {
                callback(null, code_url);
            }
        });
    } else {
        // local code analysis
        console.log("get_function_url: local code analysis");
        const sts = new AWS.STS();
        let roleArn = event["FunctionData"]["RoleArn"];
        let externalId = event["FunctionData"]["ExternalId"];
        const roleSessionName = "protego" + new Date().getTime();
        const params = {
            RoleArn: roleArn,
            RoleSessionName: roleSessionName,
            ExternalId: externalId
        };
        sts.assumeRole(params, function (err, data) {
            if (err) {
                console.error("sts.assumeRole failed with error: " + err);
                callback(err);
            } else {
                getFunction(event, data, function (err, code_url) {
                    if (err) {
                        console.error("getFunction failed with error: " + err);
                        callback(err);
                    } else {
                        callback(null, code_url);
                    }
                });
            }
        });
    }
}

function getFunction(event, data, callback) {
    const functionName = event['FunctionData']['FunctionName'];
    const region = event['FunctionData']['Region'];
    const version = event['FunctionData']['Version'];
    let lambda;
    if (data == null) {
        console.log("getFunction: remote code analysis");
        lambda = new AWS.Lambda({ apiVersion: '2015-03-31', region: region });
    } else {
        console.log("getFunction: local code analysis");
        const accessKeyId = data["Credentials"]["AccessKeyId"];
        const secretAccessKey = data["Credentials"]["SecretAccessKey"];
        const sessionToken = data["Credentials"]["SessionToken"];
        lambda = new AWS.Lambda({
            apiVersion: '2015-03-31',
            accessKeyId: accessKeyId,
            secretAccessKey: secretAccessKey,
            sessionToken: sessionToken,
            region: region
        });
    }

    var params = {
        FunctionName: functionName,
        Qualifier: version
    };
    lambda.getFunction(params, function (err, data) {
        if (err) {
            console.error("lambda.getFunction failed with error: " + err);
            callback(err);
            return;
        }

        var functionLayerData = {
            "functionCodeUrl": data['Code']['Location'],
            "layersCodeUrl": []
        };

        if (typeof data["Configuration"]["Layers"] === 'undefined' || data["Configuration"]["Layers"].length === 0) {
            callback(null, functionLayerData);
            return;
        }
        const layers = data["Configuration"]["Layers"];
        const requests = layers.map((item) => {
            return new Promise((resolve, reject) => {
                getLayerLocation(item.Arn, lambda, function (err, layerData) {
                    //check if layer data is there and continue
                    if (layerData) {
                        functionLayerData.layersCodeUrl.push(layerData);
                    }
                    resolve();
                });
            });
        });
        Promise.all(requests).then(() => {
            callback(null, functionLayerData);
        });
    });
}

function getLayerLocation(layerArn, lambda, callback) {
    const splitLayerArn = layerArn.split(":");
    const layerName = splitLayerArn.slice(0, 7).join(":");
    const layerVersionNumber = splitLayerArn[7];
    const params = {
        LayerName: layerName,
        VersionNumber: layerVersionNumber
    };

    lambda.getLayerVersion(params, function (err, data) {
        if (err) {
            console.error(`****ERROR***failed to get layer version for (lambda: ${lambda}) | layerARN: ${layerArn}`, params, err);
            callback(err, null);
            return;
        }

        const layerNameCodeLocation = {
            LayerName: layerName,
            VersionNumber: layerVersionNumber,
            CodeLocation: data["Content"]["Location"]
        };
        callback(null, layerNameCodeLocation);
    });
}

module.exports = {
    downloadCodeFromUrl,
    get_function_url,
    clearTmp,
    getTmpDirPromise
}
