const walk = require("acorn-walk");
const acorn = require("acorn");

const AWSSDKGenerator = require('./aws_sdk_generator');

const MAX_PARTS = 5;
const SERVICE_CLASS_POS = 1;
const SERVICE_FQN_POS = 2;
const SERVICE_API_POS = 3;
const API_PERMISSION_POS = 4;

class CodeParser {
    constructor(content) {
        this._content = content;
        this._apiDict = {};
        this._literals = [];
        this._services = [];
        this._apiAnalysisDict = {};
        this._apiAnalysisTmpDict = {};
    }

    getAPIUsage() {
        let context = this;
        let includeFSP = false;
        walk.simple(acorn.parse(this._content), {
            Literal(node) {
                if (typeof node.value === "string") {
                    context._parse_node(node);
                    context._literals.push(node.value);

                    if (node.value.endsWith("libosfsp.so")) {
                        includeFSP = true;
                    }
                }
            }
        });

        this._removeDuplicatesFromAPIs();
        this._createFinalApiAnalysisDict();
        let result = {
            "FunctionApiUsage": this._apiDict,
            "FunctionApiAnalysis": this._apiAnalysisDict
        };
        if (includeFSP) {
            console.log("PROTEGO_FSP dependency exists in code");
            console.log("Setting IncludesFSPCodeAnalysis to 1")
            result["IncludesFSPCodeAnalysis"] = 1;
        }
        return result;
    }

    getServiceCreations() {
        let context = this;
        walk.ancestor(acorn.parse(this._content), {
            MemberExpression(node, ancestors) {
                if (context._hasNewExpression(ancestors)) {
                    const service = context._getServiceName(node, ancestors);
                    if (service) {
                        context._services.push(service);
                    }
                }
            }
        });
        return context._services;
    }

    replaceServiceCreations(awsServices) {
        const context = this;
        let replacedContents = "";
        let lastLocation = 0;
        try {
            walk.simple(acorn.parse(this._content), {
                NewExpression(node) {
                    const memberExpression = context._getMemberExpression(node);
                    const serviceName = context._formService(memberExpression);
                    if (serviceName && awsServices.has(serviceName)) {
                        const part = context._content.substring(lastLocation, memberExpression.start);
                        replacedContents += part;
                        replacedContents += "(" + AWSSDKGenerator.getProtegoAWSNamespace() + '.' + serviceName + ")";
                        replacedContents += context._content.substring(memberExpression.end, node.end);
                        lastLocation = node.end;
                    }
                }
            });
        } catch (e) {
            console.log('Failed to replace service creations with error: ' + e);
        }

        replacedContents += this._content.substring(lastLocation);
        return replacedContents;
    }

    _formService(memberExpression){
        let className = memberExpression && memberExpression.object && memberExpression.object.property && memberExpression.object.property.name;
        if (className) {
            className += '.';
        }else{
            className = "";
        }
        return className + (memberExpression && memberExpression.property && memberExpression.property.name);
    }

    // Private methods
    _parse_node(node) {
        let literalString = String(node.value);
        if (literalString.indexOf(AWSSDKGenerator.apiUsagePrefix()) < 0) {
            return {
                "FunctionApiUsage": this._apiDict,
                "FunctionApiAnalysis": this._apiAnalysisDict
            };
        }

        const service_api_arr = literalString.split(';');
        if (service_api_arr.length !== MAX_PARTS) {
            return {
                "FunctionApiUsage": this._apiDict,
                "FunctionApiAnalysis": this._apiAnalysisDict
            };
        }

        const service_name = AWSSDKGenerator.getServiceName(service_api_arr[SERVICE_CLASS_POS]);

        // ### API USAGE ###
        if (!(service_name in this._apiDict)) {
            this._apiDict[service_name] = new Set([]);
        }

        // ### API ANALYSIS ###
        if (!(service_name in this._apiAnalysisTmpDict)) {
            this._apiAnalysisTmpDict[service_name] = {}
        }
        let action = service_api_arr[SERVICE_API_POS].charAt(0).toUpperCase() + service_api_arr[SERVICE_API_POS].slice(1);
        if (!(action in this._apiAnalysisTmpDict[service_name])) {
            this._apiAnalysisTmpDict[service_name][action] = {}
        }

        const permissions = this._getPermissions(service_api_arr, service_name);
        for (let permission of permissions) {
            // ### API USAGE ###
            const all_permissions = permission.split(':')[0] + ":*";
            if (!(this._apiDict[service_name].has(all_permissions))) {
                if (permission.indexOf("*") > 0) {
                    this._apiDict[service_name].clear();
                    this._apiDict[service_name].add(permission);
                } else {
                    if (!this._apiDict[service_name].has(permission)) {
                        this._apiDict[service_name].add(permission);
                    }
                }
            }

            // ### API ANALYSIS ###
            const resource = this._getResource(node, service_api_arr, service_name, action, permission);

            if (permission in this._apiAnalysisTmpDict[service_name][action]) {
                let resourcesList = this._apiAnalysisTmpDict[service_name][action][permission]["Resource"];
                if (resourcesList.indexOf(resource) == -1) {
                    resourcesList.push(resource);
                    this._apiAnalysisTmpDict[service_name][action][permission]["Resource"] = resourcesList;
                }
            } else {
                this._apiAnalysisTmpDict[service_name][action][permission] = {
                    "Permission": permission,
                    "Resource": [resource]
                }
            }
        }
    }

    _getPermissions(serviceAPIs, serviceName) {
        if (!AWSSDKGenerator.isSepcialOperation(serviceName, serviceAPIs[SERVICE_API_POS])) {
            return serviceAPIs[API_PERMISSION_POS].split(',');
        }

        let action = serviceAPIs[API_PERMISSION_POS].charAt(0).toUpperCase() + serviceAPIs[API_PERMISSION_POS].slice(1);
        let permissions = AWSSDKGenerator.getSpecialPermissions(serviceName, action);

        if (typeof permissions === "string") {
            return [permissions];
        }
        return permissions;
    }

    _removeDuplicatesFromAPIs() {
        for (let key in this._apiDict) {
            // convert the set to an array
            this._apiDict[key] = Array.from(this._apiDict[key]);
        }
    }

    _insertMissingPermission(serviceName, permissions) {
        for (let permission of permissions) {
            if (!this._isPermissionMissing(permission)) {
                continue;
            }
            // Remove the empty permission
            permissions.delete(permission);
            const missingPermissions = AWSSDKGenerator.getMissingPermissions(serviceName, this._literals);
            for (let missingPermission of missingPermissions) {
                permissions.add(missingPermission);
            }
            return permissions;
        }
        return permissions;
    }

    _isPermissionMissing(permission) {
        return permission.endsWith(":");
    }

    _hasNewExpression(ancestors) {
        const start = ancestors.length - 2;
        for (let i = start; i >= 0; i--) {
            if (ancestors[i].type === "MemberExpression") {
                // Since the ancestor has a MemberExpression it will be covered in the nex iteration.
                // For e.g. in case of new a.b.c() we will ignore a.b here
                return false;
            }
            if (ancestors[i].type === "NewExpression") {
                return true;
            }
        }

        return false;
    }

    _getServiceName(node, ancestors) {
        let names = [];
        let current = node;
        while (current.object) {
            names.unshift(current.property.name);
            current = current.object;
        }
        names.unshift(current.name);

        if (names[0] !== 'ProtegoAWSNamespace') {
            names[0] = this._getProtegoAWSNamespace(names[0], ancestors);
            if (names[0] !== 'ProtegoAWSNamespace') {
                return '';
            }
        }

        return names.join('.');
    }

    // This method returns ProtegoAWSNamespace if the variable is assigned to
    // ProtegoAWSNamespace, empty string otherwise
    // This will handle cases like:
    // const a = ProtegoAWSNamespace; const b = a; const c = new b.S3();
    _getProtegoAWSNamespace(name, ancestors) {
        const assignments = this._getAssignments(ancestors);
        let namespace = '';
        let value = '';
        let current = name;
        while (current !== '') {
            current = this._getValueOfVariable(current, assignments);
            if (current === 'ProtegoAWSNamespace') {
                return 'ProtegoAWSNamespace';
            }
        }
        return '';
    }

    // Returns the value of the variable assignment
    // In case of const a = b; this function will return b
    _getValueOfVariable(name, assignments) {
        for (let assignment of assignments) {
            const declarations = assignment.declarations;
            for (let declaration of declarations) {
                if (declaration.id.name === name && declaration.init !== null
                    && declaration.init.type === 'Identifier') {
                    return declaration.init.name;
                }
            }
        }
        return '';
    }

    // Gets block statements of type variable declaration from the ancestors
    _getAssignments(ancestors) {
        let assignments = [];
        for (let ancestor of ancestors) {
            if (ancestor.type === 'BlockStatement') {
                const statements = ancestor.body;
                for (let statement of statements) {
                    if (statement.type === 'VariableDeclaration') {
                        assignments.push(statement);
                    }
                }
            }
        }
        return assignments;
    }

    _createFinalApiAnalysisDict() {
        for (let service in this._apiAnalysisTmpDict) {
            if (!(service in this._apiAnalysisDict)) {
                this._apiAnalysisDict[service] = [];
            }
            for (let action in this._apiAnalysisTmpDict[service]) {
                let apiAnalysisObj = {
                    "Action": action
                }
                let rolesList = [];
                for (let roleName in this._apiAnalysisTmpDict[service][action]) {
                    let role = this._apiAnalysisTmpDict[service][action][roleName];
                    let roles = this._insertMissingRole(service, role);
                    rolesList = rolesList.concat(roles);
                }
                apiAnalysisObj["Roles"] = rolesList
                this._apiAnalysisDict[service].push(apiAnalysisObj)
            }
        }
    }

    _insertMissingRole(serviceName, role) {
        const permission = role.Permission;
        if (!this._isPermissionMissing(permission)) {
            return [role];
        }
        let result = [];
        const missingPermissions = AWSSDKGenerator.getMissingPermissions(serviceName, this._literals);
        for (let missingPermission of missingPermissions) {
            result.push({
                "Permission": missingPermission,
                "Resource": ["*"]
            });
        }
        return result;
    }

    _getResource(node, service_api_arr, service_name, action, permission) {
        const inputParamsObject = this._getInputParamsJSONObject(node);
        const resourceTemplate = require('./resources-template.json');
        let finalResource = [];
        if (service_name in resourceTemplate) {
            let paramsArray = [];
            if (action in resourceTemplate[service_name]) {
                const apiPermission = permission.split(':')[1];
                paramsArray = resourceTemplate[service_name][action][apiPermission];
            } else {
                if ("default" in resourceTemplate[service_name]) {
                    paramsArray = resourceTemplate[service_name]["default"]["default"];
                }
            }
            for (let parameter of paramsArray) {
                if (inputParamsObject[parameter]) {
                    const resource = inputParamsObject[parameter];
                    finalResource.push(this._getResourceFromEnv(resource));
                } else {
                    finalResource.push("*");
                }
            }
        }
        if (finalResource.length == 0) {
            return "*";
        }
        if (finalResource.every((val, i, arr) => val === '*')) {
            // Return '*' if all resources are *
            return '*';
        }

        return finalResource.join("/");
    }

    _getResourceFromEnv(resource) {
        if (typeof resource !== 'string') {
            return '*'
        }

        if (!resource.startsWith('process.env.')) {
            return resource;
        }

        const resourceSplit = resource.split('.');
        if (resourceSplit.length !== 3) {
            return resourceSplit;
        }

        const envVariable = process.env[resourceSplit[2]];
        if (typeof envVariable === 'undefined') {
            return "*";
        }

        return envVariable;
    }

    _getInputParamsJSONObject(node) {
        const apiUsageEndStringIndex = this._content.indexOf("__protego_api_usage_end__", node.end);
        let paramsObject = this._content.substring(node.end, apiUsageEndStringIndex);
        paramsObject = paramsObject.slice((paramsObject.indexOf("(") + 1), paramsObject.lastIndexOf(")"));
        try {
            paramsObject = this._parseApiUsageParamsObject(paramsObject);
        } catch (err) {
            console.log('Not able to identify resource from API usage');
            return {};
        }
        return paramsObject;
    }

    _parseApiUsageParamsObject(object) {
        const objectString = object.substring(1, object.length - 1);
        const paramObjectsArr = objectString.split(',');

        let result = {};

        let param;

        for (param of paramObjectsArr) {
            let keyValArr = param.split(':');
            if (keyValArr.length !== 2) {
                continue;
            }

            let value = keyValArr[1];

            if ((value[0] == "'" && value[value.length - 1] == "'") || (value[0] == '"' && value[value.length - 1] == '"')) {
                result[keyValArr[0]] = value.substring(1, value.length - 1);
            } else if (value.indexOf("process.env") > -1) {
                result[keyValArr[0]] = value;
            }
        }

        return result;
    }

    _getMemberExpression(node) {
        if (!node || !node.callee) {
            return null;
        }

        if (node.callee.type === 'MemberExpression') {
            return node.callee;
        }

        return this._getMemberExpression(node.callee);
    }
}


module.exports = CodeParser;
