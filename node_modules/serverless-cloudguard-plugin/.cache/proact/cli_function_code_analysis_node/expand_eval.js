const fs = require('fs');
const path = require('path');
const acorn = require("acorn-loose");
const walk = require("acorn-walk");
const moduleObject = require('module');
const epsagon_handler_env_key = "EPSAGON_HANDLER";  //epsagon specific change
const epsagon_handler = "epsagon.wrapper";  //epsagon specific change

const new_line = "\n";

function getUserHandlerWithEpsagonLayer(event) {
    //epsagon specific change
    const env = event["FunctionData"]["Environment"];
    if (typeof env !== "undefined") {
        const envVariables = event["FunctionData"]["Environment"]["Variables"];
        if (typeof envVariables !== "undefined") {
            for (const key in envVariables) {
                if (key === epsagon_handler_env_key) {
                    return envVariables[key];
                }
            }
        }
    }

    return "";

}

function resolveModule(moduleName, modulePath) {
    const nativeModules = Object.keys(process.binding('natives'));
    if (nativeModules.indexOf(moduleName) >= 0) {
        // If the customer module is same as built-in module use _findPath instead of require.resolve
        return moduleObject._findPath(moduleName, [modulePath]);
    }

    // Since we are webpacking the scanner use __non_webpack_require__ instead of require
    const requireObj = typeof __non_webpack_require__ !== 'undefined' ? __non_webpack_require__ : require;
    return requireObj.resolve(moduleName, { 'paths': [modulePath] });
}

function getModulePath(handlerPath, tmp_dir) {
    if (handlerPath.indexOf('/opt/') === 0) {
        const directory = path.dirname(handlerPath.substring('/opt/'.length));
        const handlerDir = path.join(tmp_dir.functionLayerLocation, directory);
        return resolveModule(path.basename(handlerPath), handlerDir);
    }

    return resolveModule(handlerPath, tmp_dir.functionCodeLocation);
}

class ExpandEval {

    getEntryPoint(event, tmp_dir) {
        let res = { "EntryPoint": null, "Error": null };
        try {
            let handlerString = event["FunctionData"]["Handler"];

            //handle epsagon case specifically
            if (handlerString.indexOf(epsagon_handler) !== -1) {
                handlerString = getUserHandlerWithEpsagonLayer(event);
            }

            const appParts = handlerString.split('.');

            if (appParts.length !== 2) {
                res.Error = "Bad handler format"
                return res;
            }

            const handlePath = appParts[0];
            const modulePath = getModulePath(handlePath, tmp_dir);

            fs.existsSync(modulePath) ? res.EntryPoint = modulePath : res.Error = "Failed to get entry point";
            return res;
        } catch (e) {
            res.Error = e.message;
            return res;
        }
    }

    expandEval(entry_point) {
        const contents = fs.readFileSync(entry_point, 'utf8').toString();
        let wfd = fs.openSync(entry_point, 'w');

        let lastEval = 0;
        try {
            walk.ancestor(acorn.parse(contents), {
                Literal(str, ancestors) {
                    let ancestor = ancestors[ancestors.length - 2];
                    if (ancestor.type == "CallExpression" && ancestor.callee.name == "eval") {
                        const part = contents.substring(lastEval, ancestor.start);
                        fs.writeSync(wfd, part);
                        fs.writeSync(wfd, new_line + str.value + new_line);
                        lastEval = ancestor.end;
                    }
                }
            });

            fs.writeSync(wfd, contents.substr(lastEval));
            fs.closeSync(wfd);
            console.log("eval expansion complete");
        } catch (err) {
            // acorn parsing fails for some ES6 code
            console.error("acorn.parse failed with error " + err);
            return;
        }
    }
}

module.exports = ExpandEval;
