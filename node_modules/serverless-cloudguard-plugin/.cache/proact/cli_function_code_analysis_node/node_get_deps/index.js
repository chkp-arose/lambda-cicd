'use strict'

const scanDependencies = require("./get_deps").scanDependencies;
const debug = require('debug')('protego');
const extend = require('node.extend');
const path = require("path");

exports.handler = function (event, context, tmpFolderPath, callback) {

    // if it is not node runtime return immediately
    if (event.FunctionData.Runtime.indexOf("node") == -1) {
        return callback(null, event)
    }

    // event data will include code url to access file

    // 1. download code to /tmp directory
    // 2. scan for list of dependencies 
    // 3. convert to our json
    debug("Starting handler");

    debug("tmpFolderPath", tmpFolderPath)
    let handlerPathToScan = path.join(
        tmpFolderPath.functionCodeLocation,
        path.dirname(event.FunctionData.Handler)
    )
    let pathToScan = [];
    pathToScan.push(handlerPathToScan);
    if (tmpFolderPath.functionLayerLocation !== "") {
        pathToScan.push(tmpFolderPath.functionLayerLocation + '/nodejs');
        const modules_array = searchNodeModulesRecursive(tmpFolderPath.functionLayerLocation);
        pathToScan = pathToScan.concat(modules_array);
    }
    debug("pathToScan", pathToScan)

    let dependencies = [];
    const requests = pathToScan.map((pathScan) => {
        return new Promise((resolve, reject) => {
            return scanDependencies(pathScan)
                .then(deps => {
                    dependencies.push(deps);
                    resolve(deps);
                })
                .catch(err => {
                    console.log(err, err.stack);
                    reject(err);
                });
        });
    });

    Promise.all(requests).then(() => {
        let res = formatResult(event, dependencies);
        callback(null, res);
    }).catch(err => callback(err));
}

function formatResult(event, deps) {
    let depsList = [];
    deps.forEach(dep => {
        Array.prototype.push.apply(depsList, createDependenciesList(dep));
    })
    if (!("Code" in event['FunctionData'])) {
        event['FunctionData']["Code"] = {}
    }
    if (depsList.length > 0) {
        event.FunctionData.Code.Dependencies = depsList;
    }
    // a place holder to analyze framework in the future...
    event.FunctionData['Framework'] = event.FunctionData.TempFramework
    if (process.env['PROTEGO_DEBUG_DBOUT'] == 'stdout') {
        console.log(JSON.stringify(event, null, 4));
    }
    return event;
}

const DEPENDENCIES = 'dependencies';

function createDependenciesList(deps) {
    let depsList = [];
    // deps.forEach(function (node) {
    //     depsList = depsList.concat(processDependency(node));
    // });
    depsList = processDependency(deps);
    depsList = new Set(depsList);
    return Array.from(depsList);
}

function addDependencyToList(childObj, depth) {
    let depsList = [];

    let childCopy = extend({}, childObj);
    delete childCopy[DEPENDENCIES];
    depsList.push(childCopy);

    depsList = depsList.concat(processDependency(childObj, depth - 1));

    return depsList;
}

function processDependency(obj, depth = 1) {
    let depsList = [];

    debug(obj[DEPENDENCIES]);
    if (typeof obj[DEPENDENCIES] !== 'undefined' && depth > 0) {
        obj[DEPENDENCIES].forEach(function (childObj) {
            if (childObj) {
                depsList = depsList.concat(addDependencyToList(childObj, depth));
            }
        });
    }
    return depsList;
}

function searchNodeModulesRecursive(dir_path) {
    const find = require('find');
    return find.dirSync(/\/node_modules$/, dir_path);
}